{"version":3,"file":"glamorous.umd.min.tiny.js","sources":["../../src/constants.js","../../src/react-compat.js","../../src/create-glamorous.js","../../src/get-glamor-classname.js","../../src/tiny.js","../../src/with-theme.js"],"sourcesContent":["/* istanbul ignore next */\nimport preval from 'preval.macro'\n\nexport const CHANNEL = '__glamorous__'\nexport const isPreact = preval`module.exports = process.env.BUILD_PREACT === 'true'`\n","import React from 'react'\nimport codegen from 'codegen.macro'\nimport {isPreact} from './constants'\n\nlet PropTypes\n\n/* istanbul ignore next */\nif (isPreact) {\n  if (!React.PropTypes) {\n    PropTypes = () => PropTypes\n    const allTypes = [\n      'array',\n      'bool',\n      'func',\n      'number',\n      'object',\n      'string',\n      'symbol',\n      'any',\n      'arrayOf',\n      'element',\n      'instanceOf',\n      'node',\n      'objectOf',\n      'oneOf',\n      'oneOfType',\n      'shape',\n      'exact',\n    ]\n    allTypes.forEach(type => {\n      PropTypes[type] = PropTypes\n    })\n  }\n  // copied from preact-compat\n  /* eslint-disable no-eq-null, eqeqeq, consistent-return */\n  if (!React.Children) {\n    const Children = {\n      map(children, fn, ctx) {\n        if (children == null) {\n          return null\n        }\n        children = Children.toArray(children)\n        if (ctx && ctx !== children) {\n          fn = fn.bind(ctx)\n        }\n        return children.map(fn)\n      },\n      forEach(children, fn, ctx) {\n        if (children == null) {\n          return null\n        }\n        children = Children.toArray(children)\n        if (ctx && ctx !== children) {\n          fn = fn.bind(ctx)\n        }\n        children.forEach(fn)\n      },\n      count(children) {\n        return (children && children.length) || 0\n      },\n      only(children) {\n        children = Children.toArray(children)\n        if (children.length !== 1) {\n          throw new Error('Children.only() expects only one child.')\n        }\n        return children[0]\n      },\n      toArray(children) {\n        if (children == null) {\n          return []\n        }\n        return [].concat(children)\n      },\n    }\n    React.Children = Children\n  }\n  /* eslint-enable no-eq-null, eqeqeq, consistent-return */\n} else if (parseFloat(React.version.slice(0, 4)) >= 15.5) {\n  /* istanbul ignore next */\n  try {\n    PropTypes = codegen`\n      if (process.env.BUILD_FORMAT === 'umd') {\n        module.exports = \"(typeof window !== 'undefined' ? window : global).PropTypes\"\n      } else {\n        module.exports = \"require('prop-types')\"\n      }\n    `\n    /* istanbul ignore next */\n  } catch (error) {\n    // ignore\n  }\n}\n/* istanbul ignore next */\nPropTypes = PropTypes || React.PropTypes\n\nexport {PropTypes}\n\n/*\neslint\n  import/no-mutable-exports:0,\n  import/prefer-default-export:0,\n  react/no-deprecated:0\n */\n","/*\n * This is a relatively small abstraction that's ripe for open sourcing.\n * Documentation is in the README.md\n */\nimport React from 'react'\nimport {PropTypes} from './react-compat'\nimport withTheme from './with-theme'\nimport getGlamorClassName from './get-glamor-classname'\n\nexport default createGlamorous\n\nfunction createGlamorous(splitProps) {\n  return glamorous\n\n  /**\n   * This is the main export and the function that people\n   * interact with most directly.\n   *\n   * It accepts a component which can be a string or\n   * a React Component and returns\n   * a \"glamorousComponentFactory\"\n   * @param {String|ReactComponent} comp the component to render\n   * @param {Object} options helpful info for the GlamorousComponents\n   * @return {Function} the glamorousComponentFactory\n   */\n  function glamorous(comp, config = {}) {\n    const {\n      rootEl,\n      displayName,\n      shouldClassNameUpdate,\n      filterProps = [],\n      forwardProps = [],\n      propsAreCssOverrides = comp.propsAreCssOverrides,\n      withProps: basePropsToApply,\n    } = config\n    Object.assign(glamorousComponentFactory, {withConfig})\n    return glamorousComponentFactory\n\n    function withConfig(newConfig) {\n      return glamorous(comp, {...config, ...newConfig})\n    }\n\n    /**\n     * This returns a React Component that renders the comp (closure)\n     * with a className based on the given glamor styles object(s)\n     * @param {...Object|Function} styles the styles to create with glamor.\n     *   If any of these are functions, they are invoked with the component\n     *   props and the return value is used.\n     * @return {ReactComponent} the ReactComponent function\n     */\n    function glamorousComponentFactory(...styles) {\n      /**\n       * This is a component which will render the comp (closure)\n       * with the glamorous styles (closure). Forwards any valid\n       * props to the underlying component.\n       */\n      const GlamorousComponent = withTheme(\n        function GlamorousInnerComponent(props, context) {\n          props = getPropsToApply(\n            GlamorousComponent.propsToApply,\n            {},\n            props,\n            context,\n          )\n          const updateClassName = shouldUpdate(props, context, this.previous)\n\n          if (shouldClassNameUpdate) {\n            this.previous = {props, context}\n          }\n\n          const {toForward, cssOverrides, cssProp} = splitProps(\n            props,\n            GlamorousComponent,\n          )\n\n          // create className to apply\n          this.className = updateClassName\n            ? getGlamorClassName({\n                styles: GlamorousComponent.styles,\n                props,\n                cssOverrides,\n                cssProp,\n                context,\n                displayName: GlamorousComponent.displayName,\n              })\n            : this.className\n\n          return React.createElement(GlamorousComponent.comp, {\n            // if innerRef is forwarded we don't want to apply it here\n            ref: 'innerRef' in toForward ? undefined : props.innerRef,\n            ...toForward,\n            className: this.className,\n          })\n        },\n        {noWarn: true, createElement: false},\n      )\n\n      GlamorousComponent.propTypes = {\n        // className accepts an object due to glamor's css function\n        // returning an object with a toString method that gives the className\n        className: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n        cssOverrides: PropTypes.object,\n        innerRef: PropTypes.func,\n        glam: PropTypes.object,\n      }\n\n      function withComponent(newComp, options = {}) {\n        const {\n          forwardProps: fwp,\n          filterProps: flp,\n          ...componentProperties\n        } = GlamorousComponent\n        return glamorous(\n          {\n            ...componentProperties,\n            comp: newComp,\n            rootEl: getRootEl(newComp),\n          },\n          {\n            // allows the forwardProps and filterProps to be overridden\n            forwardProps: fwp,\n            filterProps: flp,\n            ...options,\n          },\n        )()\n      }\n\n      function withProps(...propsToApply) {\n        return glamorous(GlamorousComponent, {withProps: propsToApply})()\n      }\n\n      function shouldUpdate(props, context, previous) {\n        // exiting early so components which do not use this\n        // optimization are not penalized by hanging onto\n        // references to previous props and context\n        if (!shouldClassNameUpdate) {\n          return true\n        }\n        let update = true\n        if (previous) {\n          if (\n            !shouldClassNameUpdate(\n              previous.props,\n              props,\n              previous.context,\n              context,\n            )\n          ) {\n            update = false\n          }\n        }\n\n        return update\n      }\n\n      Object.assign(\n        GlamorousComponent,\n        getGlamorousComponentMetadata({\n          comp,\n          styles,\n          rootEl,\n          filterProps,\n          forwardProps,\n          displayName,\n          propsToApply: basePropsToApply,\n        }),\n        {\n          isGlamorousComponent: true,\n          propsAreCssOverrides,\n          withComponent,\n          withProps,\n          withConfig,\n        },\n      )\n      return GlamorousComponent\n    }\n  }\n\n  function getGlamorousComponentMetadata({\n    comp,\n    styles,\n    rootEl,\n    filterProps,\n    forwardProps,\n    displayName,\n    propsToApply: basePropsToApply,\n  }) {\n    const componentsComp = comp.comp ? comp.comp : comp\n    const propsToApply = comp.propsToApply\n      ? [...comp.propsToApply, ...arrayify(basePropsToApply)]\n      : arrayify(basePropsToApply)\n    return {\n      // join styles together (for anyone doing: glamorous(glamorous.a({}), {}))\n      styles: when(comp.styles, styles),\n      // keep track of the ultimate rootEl to render (we never\n      // actually render anything but\n      // the base component, even when people wrap a glamorous\n      // component in glamorous\n      comp: componentsComp,\n      rootEl: rootEl || getRootEl(comp),\n      // join forwardProps and filterProps\n      // (for anyone doing: glamorous(glamorous.a({}), {}))\n      forwardProps: when(comp.forwardProps, forwardProps),\n      filterProps: when(comp.filterProps, filterProps),\n      // set the displayName to something that's slightly more\n      // helpful than `GlamorousComponent` :)\n      displayName: displayName || `glamorous(${getDisplayName(comp)})`,\n      // these are props that should be applied to the component at render time\n      propsToApply,\n    }\n  }\n}\n\n/**\n * reduces the propsToApply given to a single props object\n * @param {Array} propsToApply an array of propsToApply objects:\n *   - object\n *   - array of propsToApply items\n *   - function that accepts the accumulated props and the context\n * @param {Object} accumulator an object to apply props onto\n * @param {Object} props the props that should ultimately take precedence\n * @param {*} context the context object\n * @return {Object} the reduced props\n */\nfunction getPropsToApply(propsToApply, accumulator, props, context) {\n  // using forEach rather than reduce here because the reduce solution\n  // effectively did the same thing because we manipulate the `accumulator`\n  propsToApply.forEach(propsToApplyItem => {\n    if (typeof propsToApplyItem === 'function') {\n      return Object.assign(\n        accumulator,\n        propsToApplyItem(Object.assign({}, accumulator, props), context),\n      )\n    } else if (Array.isArray(propsToApplyItem)) {\n      return Object.assign(\n        accumulator,\n        getPropsToApply(propsToApplyItem, accumulator, props, context),\n      )\n    }\n    return Object.assign(accumulator, propsToApplyItem)\n  })\n  // props wins\n  return Object.assign(accumulator, props)\n}\n\nfunction arrayify(x = []) {\n  return Array.isArray(x) ? x : [x]\n}\n\nfunction when(comp, prop) {\n  return comp ? comp.concat(prop) : prop\n}\n\nfunction getRootEl(comp) {\n  return comp.rootEl ? comp.rootEl : comp.comp || comp\n}\n\nfunction getDisplayName(comp) {\n  return typeof comp === 'string'\n    ? comp\n    : comp.displayName || comp.name || 'unknown'\n}\n","import {css} from 'glamor'\n/**\n * This function takes a className string and gets all the\n * associated glamor styles. It's used to merge glamor styles\n * from a className to make sure that specificity is not\n * a problem when passing a className to a component.\n * @param {String} [className=''] the className string\n * @return {Object} { glamorStyles, glamorlessClassName }\n *   - glamorStyles is an array of all the glamor styles objects\n *   - glamorlessClassName is the rest of the className string\n *     without the glamor classNames\n */\nfunction extractGlamorStyles(className) {\n  const glamorlessClassName = []\n  const glamorStyles = []\n  className\n    .toString()\n    .split(' ')\n    .forEach(name => {\n      if (name.indexOf('css-') === 0) {\n        const style = buildGlamorSrcFromClassName(name)\n        glamorStyles.push(style)\n      } else {\n        glamorlessClassName.push(name)\n      }\n    })\n\n  return {glamorlessClassName, glamorStyles}\n}\n\n/** Glamor's css function returns an object with the shape\n *\n * {\n *   [`data-css-${hash}`]: '',\n *   toString() { return `css-${hash}` }\n * }\n *\n * Whenever glamor's build function encounters an object with\n * this shape it just pulls the resulting styles from the cache.\n *\n * note: the toString method is not needed to qualify the shape\n **/\nfunction buildGlamorSrcFromClassName(className) {\n  return {[`data-${className}`]: ''}\n}\n\nexport default getGlamorClassName\n\nfunction getGlamorClassName({\n  styles,\n  props,\n  cssOverrides,\n  cssProp,\n  context,\n  displayName,\n}) {\n  const {mappedArgs, nonGlamorClassNames} = handleStyles(\n    [...styles, props.className, cssOverrides, cssProp],\n    props,\n    context,\n  )\n  // eslint-disable-next-line max-len\n  const isDev = process.env.NODE_ENV === 'development' || !process.env.NODE_ENV\n  const devRules = isDev ? {label: displayName} : null\n  const glamorClassName = css(devRules, ...mappedArgs).toString()\n  const extras = nonGlamorClassNames.join(' ').trim()\n  return `${glamorClassName} ${extras}`.trim()\n}\n\n// this next function is on a \"hot\" code-path\n// so it's pretty complex to make sure it's fast.\n// eslint-disable-next-line complexity\nfunction handleStyles(styles, props, context) {\n  let current\n  const mappedArgs = []\n  const nonGlamorClassNames = []\n  for (let i = 0; i < styles.length; i++) {\n    current = styles[i]\n    if (typeof current === 'function') {\n      const result = current(props, context)\n      if (typeof result === 'string') {\n        const {glamorStyles, glamorlessClassName} = extractGlamorStyles(result)\n        mappedArgs.push(...glamorStyles)\n        nonGlamorClassNames.push(...glamorlessClassName)\n      } else {\n        mappedArgs.push(result)\n      }\n    } else if (typeof current === 'string') {\n      const {glamorStyles, glamorlessClassName} = extractGlamorStyles(current)\n      mappedArgs.push(...glamorStyles)\n      nonGlamorClassNames.push(...glamorlessClassName)\n    } else if (Array.isArray(current)) {\n      const recursed = handleStyles(current, props, context)\n      mappedArgs.push(...recursed.mappedArgs)\n      nonGlamorClassNames.push(...recursed.nonGlamorClassNames)\n    } else {\n      mappedArgs.push(current)\n    }\n  }\n  return {mappedArgs, nonGlamorClassNames}\n}\n","/* eslint no-unused-vars:0 */\nimport createGlamorous from './create-glamorous'\n\nfunction splitProps(\n  {\n    css: cssProp,\n    innerRef,\n    // these are plucked off\n    theme, // because they\n    className, // should never\n    glam, // be forwarded\n    // to the lower\n    // component ever\n    ...rest\n  },\n  {forwardProps},\n) {\n  // forward innerRef if user wishes to do so\n  if (innerRef !== undefined && forwardProps.indexOf('innerRef') !== -1) {\n    rest.innerRef = innerRef\n  }\n  return {toForward: rest, cssProp}\n}\n\nconst glamorous = createGlamorous(splitProps)\n\nexport default glamorous\n","import React from 'react'\n\nimport {CHANNEL} from './constants'\nimport {PropTypes} from './react-compat'\n\nfunction generateWarningMessage(Comp) {\n  const componentName = Comp.displayName || Comp.name || 'FunctionComponent'\n  // eslint-disable-next-line max-len\n  return `glamorous warning: Expected component called \"${componentName}\" which uses withTheme to be within a ThemeProvider but none was found.`\n}\n\nexport default function withTheme(\n  ComponentToTheme,\n  {noWarn = false, createElement = true} = {},\n) {\n  class ThemedComponent extends React.Component {\n    static propTypes = {\n      theme: PropTypes.object,\n    }\n    warned = noWarn\n    state = {theme: {}}\n    setTheme = theme => this.setState({theme})\n\n    // eslint-disable-next-line complexity\n    componentWillMount() {\n      if (!this.context[CHANNEL]) {\n        if (process.env.NODE_ENV !== 'production' && !this.warned) {\n          this.warned = true\n          // eslint-disable-next-line no-console\n          console.warn(generateWarningMessage(ComponentToTheme))\n        }\n      }\n      const {theme} = this.props\n      if (this.context[CHANNEL]) {\n        // if a theme is provided via props,\n        // it takes precedence over context\n        this.setTheme(theme ? theme : this.context[CHANNEL].getState())\n      } else {\n        this.setTheme(theme || {})\n      }\n    }\n\n    componentWillReceiveProps(nextProps) {\n      if (this.props.theme !== nextProps.theme) {\n        this.setTheme(nextProps.theme)\n      }\n    }\n\n    componentDidMount() {\n      if (this.context[CHANNEL] && !this.props.theme) {\n        // subscribe to future theme changes\n        this.subscriptionId = this.context[CHANNEL].subscribe(this.setTheme)\n      }\n    }\n\n    componentWillUnmount() {\n      // cleanup subscription\n      this.subscriptionId &&\n        this.context[CHANNEL].unsubscribe(this.subscriptionId)\n    }\n\n    render() {\n      if (createElement) {\n        return <ComponentToTheme {...this.props} {...this.state} />\n      } else {\n        // this allows us to effectively use the GlamorousComponent\n        // as our `render` method without going through lifecycle hooks.\n        // Also allows us to forward the context in the scenario where\n        // a user wants to add more context.\n        // eslint-disable-next-line babel/new-cap\n        return ComponentToTheme.call(\n          this,\n          {...this.props, ...this.state},\n          this.context,\n        )\n      }\n    }\n  }\n\n  const defaultContextTypes = {\n    [CHANNEL]: PropTypes.object,\n  }\n\n  let userDefinedContextTypes = null\n\n  // configure the contextTypes to be settable by the user,\n  // however also retaining the glamorous channel.\n  Object.defineProperty(ThemedComponent, 'contextTypes', {\n    enumerable: true,\n    configurable: true,\n    set(value) {\n      userDefinedContextTypes = value\n    },\n    get() {\n      // if the user has provided a contextTypes definition,\n      // merge the default context types with the provided ones.\n      if (userDefinedContextTypes) {\n        return {\n          ...defaultContextTypes,\n          ...userDefinedContextTypes,\n        }\n      }\n      return defaultContextTypes\n    },\n  })\n\n  return ThemedComponent\n}\n"],"names":["CHANNEL","PropTypes","forEach","type","React","Children","children","fn","ctx","toArray","bind","map","length","Error","concat","splitProps","extractGlamorStyles","className","glamorlessClassName","glamorStyles","toString","split","name","indexOf","style","push","getGlamorClassName","styles","props","cssOverrides","cssProp","context","displayName","handleStyles","current","mappedArgs","nonGlamorClassNames","i","result","Array","isArray","recursed","css","join","trim","arrayify","x","when","comp","prop","getRootEl","rootEl","forwardProps","innerRef","rest","theme","glam","undefined","toForward","glamorous","config","shouldClassNameUpdate","filterProps","propsAreCssOverrides","basePropsToApply","withProps","assign","glamorousComponentFactory","withConfig","newConfig","componentsComp","propsToApply","GlamorousComponent","ComponentToTheme","noWarn","createElement","ThemedComponent","warned","state","setTheme","_this","setState","this","getState","nextProps","subscriptionId","subscribe","unsubscribe","h","call","Component","defaultContextTypes","object","userDefinedContextTypes","defineProperty","value","withTheme","updateClassName","previous","update","shouldUpdate","getPropsToApply","accumulator","propsToApplyItem","Object","newComp","options","fwp","flp","componentProperties"],"mappings":"gQAGO,IAAMA,EAAU,gBCCnBC,2DAISA,cACG,kBAAMA,IAEhB,QACA,OACA,OACA,SACA,SACA,SACA,SACA,MACA,UACA,UACA,aACA,OACA,WACA,QACA,YACA,QACA,SAEOC,QAAQ,cACLC,GAAQF,MAKjBG,EAAMC,SAAU,KACbA,gBACAC,EAAUC,EAAIC,UACA,MAAZF,EACK,QAEED,EAASI,QAAQH,GACxBE,GAAOA,IAAQF,MACZC,EAAGG,KAAKF,IAERF,EAASK,IAAIJ,sBAEdD,EAAUC,EAAIC,MACJ,MAAZF,SACK,OAEED,EAASI,QAAQH,GACxBE,GAAOA,IAAQF,MACZC,EAAGG,KAAKF,MAENN,QAAQK,mBAEbD,UACIA,GAAYA,EAASM,QAAW,iBAErCN,MAEqB,OADbD,EAASI,QAAQH,IACfM,aACL,IAAIC,MAAM,kDAEXP,EAAS,qBAEVA,UACU,MAAZA,QAGMQ,OAAOR,OAGfD,SAAWA,EAmBrBJ,EAAYA,GAAaG,EAAMH,cClFNc,s0CCCzB,SAASC,EAAoBC,OACrBC,KACAC,cAEHC,WACAC,MAAM,KACNnB,QAAQ,eACsB,IAAzBoB,EAAKC,QAAQ,QAAe,KACxBC,eAAoCF,EAuBjB,MAtBZG,KAAKD,UAEEC,KAAKH,MAIvBJ,sBAAqBC,gBAmB/B,SAESO,SACPC,IAAAA,OACAC,IAAAA,MACAC,IAAAA,aACAC,IAAAA,QACAC,IAAAA,aACAC,YAkBF,SAASC,EAAaN,EAAQC,EAAOG,OAC/BG,aACEC,SACAC,SACD,IAAIC,EAAI,EAAGA,EAAIV,EAAOf,OAAQyB,OAEV,qBADbV,EAAOU,IACkB,KAC3BC,EAASJ,EAAQN,EAAOG,MACR,iBAAXO,EAAqB,OACctB,EAAoBsB,GAAzDnB,IAAAA,aAAcD,IAAAA,sBACVO,eAAQN,MACCM,eAAQP,WAEjBO,KAAKa,QAEb,GAAuB,iBAAZJ,EAAsB,OACMlB,EAAoBkB,GAAzDf,IAAAA,aAAcD,IAAAA,sBACVO,eAAQN,MACCM,eAAQP,SACvB,GAAIqB,MAAMC,QAAQN,GAAU,KAC3BO,EAAWR,EAAaC,EAASN,EAAOG,KACnCN,eAAQgB,EAASN,eACRV,eAAQgB,EAASL,6BAE1BX,KAAKS,UAGZC,aAAYC,uBA3CsBH,aACpCN,IAAQC,EAAMX,UAAWY,EAAcC,IAC3CF,EACAG,IAHKI,IAAAA,WAAYC,IAAAA,2BAQKM,oBADwB,eACPP,KAAYf,eACtCgB,EAAoBO,KAAK,KAAKC,QACPA,ODmLxC,SAASC,QAASC,mEACTP,MAAMC,QAAQM,GAAKA,GAAKA,GAGjC,SAASC,EAAKC,EAAMC,UACXD,EAAOA,EAAKlC,OAAOmC,GAAQA,EAGpC,SAASC,EAAUF,UACVA,EAAKG,OAASH,EAAKG,OAASH,EAAKA,MAAQA,SAnPzBjC,EEVzB,kBAcGqC,IAAAA,aAVMtB,IAALY,IACAW,IAAAA,SAOGC,KALHC,QACAtC,YACAuC,qEAQeC,IAAbJ,IAAgE,IAAtCD,EAAa7B,QAAQ,gBAC5C8B,SAAWA,IAEVK,UAAWJ,EAAMxB,qBFIhB6B,EAAUX,OAAMY,4DAErBT,EAOES,EAPFT,OACAnB,EAME4B,EANF5B,YACA6B,EAKED,EALFC,wBAKED,EAJFE,YAAAA,oBAIEF,EAHFR,aAAAA,oBAGEQ,EAFFG,qBAAAA,aAAuBf,EAAKe,uBACjBC,EACTJ,EADFK,wBAEKC,OAAOC,GAA4BC,eACnCD,WAEEC,EAAWC,UACXV,EAAUX,OAAUY,EAAWS,aAW/BF,+BAA6BxC,+CAiItCqB,EACArB,EACAwB,EACAW,EACAV,EACApB,EACcgC,EAERM,EACAC,EAqEcvB,EAzMZwB,WG5CVC,uEACCC,OAAAA,oBAAgBC,cAAAA,gBAEXC,iNAIJC,OAASH,IACTI,OAASvB,YACTwB,SAAW,mBAASC,EAAKC,UAAU1B,gFAI5B2B,KAAKnD,QAAQ/B,OAOXuD,EAAS2B,KAAKtD,MAAd2B,MACH2B,KAAKnD,QAAQ/B,QAGV+E,SAASxB,GAAgB2B,KAAKnD,QAAQ/B,GAASmF,iBAE/CJ,SAASxB,yDAIQ6B,GACpBF,KAAKtD,MAAM2B,QAAU6B,EAAU7B,YAC5BwB,SAASK,EAAU7B,mDAKtB2B,KAAKnD,QAAQ/B,KAAakF,KAAKtD,MAAM2B,aAElC8B,eAAiBH,KAAKnD,QAAQ/B,GAASsF,UAAUJ,KAAKH,+DAMxDM,gBACHH,KAAKnD,QAAQ/B,GAASuF,YAAYL,KAAKG,wDAIrCV,EACKa,EAACf,OAAqBS,KAAKtD,MAAWsD,KAAKJ,QAO3CL,EAAiBgB,KACtBP,UACIA,KAAKtD,MAAUsD,KAAKJ,OACxBI,KAAKnD,gBA1DiB3B,EAAMsF,WAgE9BC,OACH3F,EAAUC,EAAU2F,QAGnBC,EAA0B,mBAIvBC,eAAelB,EAAiB,4BACzB,gBACE,eACVmB,KACwBA,yBAKtBF,OAEGF,EACAE,GAGAF,KAIJf,EHlDwBoB,CACzB,SAAiCpE,EAAOG,OAOhCkE,WAmEYrE,EAAOG,EAASmE,OAI/BrC,SACI,MAELsC,GAAS,SACTD,IAECrC,EACCqC,EAAStE,MACTA,EACAsE,EAASnE,QACTA,QAGO,IAINoE,EAxFmBC,GAgKlC,SAASC,EAAgB9B,EAAc+B,EAAa1E,EAAOG,YAG5C7B,QAAQ,kBACa,mBAArBqG,EACFC,OAAOtC,OACZoC,EACAC,EAAiBC,OAAOtC,UAAWoC,EAAa1E,GAAQG,IAEjDQ,MAAMC,QAAQ+D,GAChBC,OAAOtC,OACZoC,EACAD,EAAgBE,EAAkBD,EAAa1E,EAAOG,IAGnDyE,OAAOtC,OAAOoC,EAAaC,KAG7BC,OAAOtC,OAAOoC,EAAa1E,GAxLlByE,CACN7B,EAAmBD,gBAEnB3C,EACAG,GAE0CA,EAASmD,KAAKgB,UAEtDrC,SACGqC,UAAYtE,QAAOG,kBAGiBhB,EACzCa,EACA4C,GAFKd,IAAAA,UAAW7B,IAAAA,aAAcC,IAAAA,oBAM3Bb,UAAYgF,EACbvE,UACU8C,EAAmB7C,8DAKd6C,EAAmBxC,cAElCkD,KAAKjE,UAEFb,EAAMuE,cAAcH,EAAmBxB,YAEvC,aAAcU,OAAYD,EAAY7B,EAAMyB,UAC9CK,aACQwB,KAAKjE,eAGnByD,QAAQ,EAAMC,eAAe,kBA6DzBT,OACLM,GAuBJxB,uFAfoBgB,IAepBhB,KACArB,IAAAA,OACAwB,IAAAA,OACAW,IAAAA,YACAV,IAAAA,aACApB,IAAAA,YACcgC,IAAdO,aAEMD,EAAiBtB,EAAKA,KAAOA,EAAKA,KAAOA,EACzCuB,EAAevB,EAAKuB,yBAClBvB,EAAKuB,gBAAiB1B,EAASmB,KACnCnB,EAASmB,WAGHjB,EAAKC,EAAKrB,OAAQA,QAKpB2C,SACEnB,GAAUD,EAAUF,gBAGdD,EAAKC,EAAKI,aAAcA,eACzBL,EAAKC,EAAKc,YAAaA,eAGvB9B,iBAmDKgB,EAnDsCA,EAoDrC,iBAATA,EACVA,EACAA,EAAKhB,aAAegB,EAAK1B,MAAQ,uDA7FP,uCA7D1B,SAAuBmF,OAASC,4DAEdC,EAGZnC,EAHFpB,aACawD,EAEXpC,EAFFV,YACG+C,IACDrC,yCACGb,OAEAkD,QACGJ,SACEvD,EAAUuD,qBAIJE,cACDC,GACVF,GAVA/C,cAeT,sCAAsBY,gDACbZ,EAAUa,GAAqBP,UAAWM,GAA1CZ,mBA8CFa"}